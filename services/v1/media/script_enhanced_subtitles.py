import os
import json
import srt
import logging
import difflib
from datetime import timedelta
from typing import List, Dict, Tuple, Optional

# Set up logging
logger = logging.getLogger(__name__)

def align_script_with_subtitles(script_text: str, srt_file_path: str, output_srt_path: Optional[str] = None) -> str:
    """
    Align a voice-over script with automatically generated subtitles to create more accurate subtitles.
    
    Args:
        script_text: The voice-over script text (accurate text)
        srt_file_path: Path to the SRT file generated by transcription
        output_srt_path: Path to save the enhanced SRT file (optional)
        
    Returns:
        Path to the enhanced SRT file
    """
    logger.info(f"Aligning script with subtitles from {srt_file_path}")
    
    # Read the SRT file
    try:
        with open(srt_file_path, 'r', encoding='utf-8') as f:
            srt_content = f.read()
            
        # Parse the SRT content
        subtitles = list(srt.parse(srt_content))
        
        if not subtitles:
            logger.warning("No subtitles found in SRT file")
            return srt_file_path
            
        logger.info(f"Found {len(subtitles)} subtitle segments")
    except Exception as e:
        logger.error(f"Error reading SRT file: {str(e)}")
        return srt_file_path
    
    # Process the script text
    # Remove extra whitespace and normalize line breaks
    script_text = script_text.strip()
    script_lines = [line.strip() for line in script_text.split('\n') if line.strip()]
    
    # If script is empty, return original SRT
    if not script_lines:
        logger.warning("Script text is empty")
        return srt_file_path
    
    logger.info(f"Script contains {len(script_lines)} lines")
    
    # Combine all subtitle text to get the full transcription
    full_transcription = " ".join(subtitle.content for subtitle in subtitles)
    
    # Combine all script lines to get the full script
    full_script = " ".join(script_lines)
    
    # Now we need to align the script with the transcription
    # We'll use a sequence matcher to find the best alignment
    
    # For Thai text, we need to handle it differently than English
    # We'll use character-level matching instead of word-level
    is_thai = any('\u0E00' <= c <= '\u0E7F' for c in full_script)
    
    if is_thai:
        logger.info("Detected Thai text, using character-level alignment")
        # For Thai, we'll use character-level alignment
        matcher = difflib.SequenceMatcher(None, full_transcription, full_script)
        
        # Get the best alignment
        enhanced_subtitles = []
        
        for subtitle in subtitles:
            # Find the best match for this subtitle text in the script
            best_ratio = 0
            best_match = subtitle.content
            
            # Get the start and end position of this subtitle in the full transcription
            start_pos = full_transcription.find(subtitle.content)
            if start_pos == -1:
                # If exact match not found, use fuzzy matching
                for i in range(len(full_script) - len(subtitle.content) + 1):
                    script_segment = full_script[i:i+len(subtitle.content)]
                    ratio = difflib.SequenceMatcher(None, subtitle.content, script_segment).ratio()
                    if ratio > best_ratio:
                        best_ratio = ratio
                        best_match = script_segment
            else:
                end_pos = start_pos + len(subtitle.content)
                
                # Find the corresponding segment in the script
                blocks = matcher.get_matching_blocks()
                script_start = None
                script_end = None
                
                for block in blocks:
                    trans_idx, script_idx, size = block
                    if trans_idx <= start_pos < trans_idx + size:
                        # Found the start position
                        offset = start_pos - trans_idx
                        script_start = script_idx + offset
                    
                    if trans_idx <= end_pos < trans_idx + size:
                        # Found the end position
                        offset = end_pos - trans_idx
                        script_end = script_idx + offset
                
                if script_start is not None and script_end is not None:
                    best_match = full_script[script_start:script_end]
            
            # Create a new subtitle with the enhanced text
            enhanced_subtitles.append(
                srt.Subtitle(
                    index=subtitle.index,
                    start=subtitle.start,
                    end=subtitle.end,
                    content=best_match
                )
            )
    else:
        # For non-Thai text, we can use word-level alignment
        logger.info("Using word-level alignment for non-Thai text")
        
        # Split into words
        transcription_words = full_transcription.split()
        script_words = full_script.split()
        
        # Create a sequence matcher
        matcher = difflib.SequenceMatcher(None, transcription_words, script_words)
        
        # Get the matching blocks
        blocks = matcher.get_matching_blocks()
        
        # Create a mapping from transcription word indices to script word indices
        word_mapping = {}
        for block in blocks:
            trans_idx, script_idx, size = block
            for i in range(size):
                word_mapping[trans_idx + i] = script_idx + i
        
        # Enhance each subtitle
        enhanced_subtitles = []
        word_index = 0
        
        for subtitle in subtitles:
            subtitle_words = subtitle.content.split()
            enhanced_words = []
            
            for word in subtitle_words:
                if word_index in word_mapping:
                    script_idx = word_mapping[word_index]
                    if script_idx < len(script_words):
                        enhanced_words.append(script_words[script_idx])
                    else:
                        enhanced_words.append(word)
                else:
                    enhanced_words.append(word)
                word_index += 1
            
            # Create a new subtitle with the enhanced text
            enhanced_subtitles.append(
                srt.Subtitle(
                    index=subtitle.index,
                    start=subtitle.start,
                    end=subtitle.end,
                    content=" ".join(enhanced_words)
                )
            )
    
    # Compose the enhanced SRT content
    enhanced_srt_content = srt.compose(enhanced_subtitles)
    
    # Save the enhanced SRT file
    if not output_srt_path:
        output_srt_path = srt_file_path.replace('.srt', '_enhanced.srt')
    
    with open(output_srt_path, 'w', encoding='utf-8') as f:
        f.write(enhanced_srt_content)
    
    logger.info(f"Enhanced SRT file saved to {output_srt_path}")
    return output_srt_path

def enhance_subtitles_from_segments(script_text: str, segments: List[Dict], output_srt_path: str) -> str:
    """
    Create enhanced subtitles from transcription segments and a script.
    
    Args:
        script_text: The voice-over script text (accurate text)
        segments: List of transcription segments from Whisper
        output_srt_path: Path to save the enhanced SRT file
        
    Returns:
        Path to the enhanced SRT file
    """
    logger.info(f"Enhancing subtitles from {len(segments)} segments")
    
    # Convert segments to SRT format
    subtitles = []
    for i, segment in enumerate(segments):
        start_time = timedelta(seconds=segment['start'])
        end_time = timedelta(seconds=segment['end'])
        
        subtitles.append(
            srt.Subtitle(
                index=i+1,
                start=start_time,
                end=end_time,
                content=segment['text']
            )
        )
    
    # Create a temporary SRT file
    temp_srt_path = output_srt_path.replace('.srt', '_temp.srt')
    with open(temp_srt_path, 'w', encoding='utf-8') as f:
        f.write(srt.compose(subtitles))
    
    # Align the script with the subtitles
    enhanced_srt_path = align_script_with_subtitles(script_text, temp_srt_path, output_srt_path)
    
    # Clean up the temporary file
    try:
        os.remove(temp_srt_path)
    except:
        pass
    
    return enhanced_srt_path
