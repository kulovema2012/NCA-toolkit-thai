import os
import json
import srt
import logging
import difflib
import unicodedata
import datetime
from datetime import timedelta
from typing import List, Dict, Tuple, Optional, Union
from services.cloud_storage import upload_to_cloud_storage
import re
import tempfile

# Import PyThaiNLP for better Thai word segmentation
try:
    from pythainlp.tokenize import word_tokenize
    PYTHAINLP_AVAILABLE = True
except ImportError:
    PYTHAINLP_AVAILABLE = False
    logging.warning("PyThaiNLP not available. Thai word segmentation will be limited.")

# Set up logging
logger = logging.getLogger(__name__)

def align_script_with_subtitles(script_text: str, srt_file_path: str, output_srt_path: Optional[str] = None, upload_to_cloud: bool = True) -> Union[str, Dict[str, str]]:
    """
    Align a voice-over script with automatically generated subtitles to create more accurate subtitles.
    
    Args:
        script_text: The voice-over script text (accurate text)
        srt_file_path: Path to the SRT file generated by transcription
        output_srt_path: Path to save the enhanced SRT file (optional)
        upload_to_cloud: Whether to upload the SRT file to cloud storage (default: True)
        
    Returns:
        If upload_to_cloud is True: Dict with local_path and cloud_url of the enhanced SRT file
        If upload_to_cloud is False: Path to the enhanced SRT file (local path)
    """
    logger.info(f"Aligning script with subtitles from {srt_file_path}")
    
    # Read the SRT file
    try:
        with open(srt_file_path, 'r', encoding='utf-8-sig') as f:
            srt_content = f.read()
            
        # Parse the SRT content
        subtitles = list(srt.parse(srt_content))
        
        if not subtitles:
            logger.warning("No subtitles found in SRT file")
            return srt_file_path
            
        logger.info(f"Found {len(subtitles)} subtitle segments")
    except Exception as e:
        logger.error(f"Error reading SRT file: {str(e)}")
        return srt_file_path
    
    # Process the script text
    # Remove extra whitespace and normalize line breaks
    script_text = script_text.strip()
    
    # Special handling for Thai text - normalize Unicode characters
    script_text = unicodedata.normalize('NFC', script_text)
    
    # Clean up script text - remove excess whitespace and normalize line breaks
    script_text = re.sub(r'\s+', ' ', script_text)
    script_lines = [line.strip() for line in script_text.split('\n') if line.strip()]
    
    # If script is empty, return original SRT
    if not script_lines:
        logger.warning("Script text is empty")
        return srt_file_path
    
    # Join all script lines into a single string for alignment
    full_script = ' '.join(script_lines)
    
    # Extract all transcribed text from subtitles
    transcribed_text = ' '.join([sub.content for sub in subtitles])
    
    # Special handling for Thai text - normalize Unicode characters
    transcribed_text = unicodedata.normalize('NFC', transcribed_text)
    
    logger.info(f"Script length: {len(full_script)} characters")
    logger.info(f"Transcription length: {len(transcribed_text)} characters")
    
    # Determine if we're working with Thai text
    is_thai = any('\u0E00' <= c <= '\u0E7F' for c in full_script)
    if is_thai:
        logger.info("Detected Thai text, using Thai-specific alignment")
        # For Thai, we need to do character-level alignment since Thai doesn't use spaces between words
        aligned_subtitles = align_thai_text(full_script, subtitles)
    else:
        # For non-Thai languages, use the standard word-level alignment
        aligned_subtitles = align_standard_text(full_script, subtitles)
    
    # Write the enhanced SRT file
    if not output_srt_path:
        dir_name = os.path.dirname(srt_file_path)
        base_name = os.path.basename(srt_file_path)
        output_srt_path = os.path.join(dir_name, f"enhanced_{base_name}")
    
    try:
        with open(output_srt_path, 'w', encoding='utf-8') as f:
            f.write(srt.compose(aligned_subtitles))
        logger.info(f"Enhanced SRT file written to {output_srt_path}")
        
        # Upload to cloud storage if requested
        if upload_to_cloud:
            try:
                # Generate a destination path with a unique name
                import uuid
                filename = os.path.basename(output_srt_path)
                destination_path = f"subtitles/{uuid.uuid4()}_{filename}"
                
                # Upload the file to cloud storage
                cloud_url = upload_to_cloud_storage(output_srt_path, destination_path)
                logger.info(f"Enhanced SRT file uploaded to cloud storage: {cloud_url}")
                
                # Return both the local path and cloud URL
                return {
                    "local_path": output_srt_path,
                    "cloud_url": cloud_url
                }
            except Exception as e:
                logger.error(f"Error uploading SRT file to cloud storage: {str(e)}")
                # If cloud upload fails, return the local path
                return output_srt_path
        
        # If cloud upload is not requested, return the local path
        return output_srt_path
        
    except Exception as e:
        logger.error(f"Error writing enhanced SRT file: {str(e)}")
        return srt_file_path

def segment_thai_text(text: str) -> List[str]:
    """
    Segment Thai text into words using PyThaiNLP if available.
    Falls back to character-by-character segmentation if PyThaiNLP is not available.
    
    Args:
        text: Thai text to segment
        
    Returns:
        List of Thai words
    """
    if PYTHAINLP_AVAILABLE:
        try:
            # Use PyThaiNLP's neural network model for better segmentation
            words = word_tokenize(text, engine="newmm")
            return words
        except Exception as e:
            logger.warning(f"Error using PyThaiNLP for word segmentation: {str(e)}")
    
    # Fallback to simple character segmentation (not ideal but better than nothing)
    return list(text)

def align_thai_text(script_text: str, subtitles: List[srt.Subtitle]) -> List[srt.Subtitle]:
    """
    Align Thai script text with subtitles using improved Thai-specific alignment.
    
    Args:
        script_text: The Thai script text
        subtitles: List of subtitle objects
        
    Returns:
        List of aligned subtitle objects
    """
    # Create a list to store the aligned subtitles
    aligned_subtitles = []
    
    # Current position in the script text
    script_pos = 0
    
    # Pre-segment the script text for better alignment
    segmented_script = segment_thai_text(script_text)
    script_with_markers = " ".join(segmented_script)
    
    # Process each subtitle
    for i, sub in enumerate(subtitles):
        # Skip empty subtitles
        if not sub.content.strip():
            aligned_subtitles.append(sub)
            continue
        
        # Normalize and clean the subtitle content
        sub_content = unicodedata.normalize('NFC', sub.content.strip())
        
        # Segment the subtitle content
        segmented_sub = segment_thai_text(sub_content)
        
        # Find the best match for this subtitle in the script
        best_match = ""
        best_score = 0
        best_pos = script_pos
        
        # Try different window sizes around the current position
        # Use a larger window for better context
        window_size = max(len(sub_content) * 10, 200)  # Increased window size
        start_pos = max(0, script_pos - window_size)
        end_pos = min(len(script_text), script_pos + len(sub_content) + window_size)
        
        search_text = script_text[start_pos:end_pos]
        
        # Use a combination of approaches for better matching
        
        # 1. First try exact matching for short segments
        if len(sub_content) < 20:
            exact_match_pos = search_text.find(sub_content)
            if exact_match_pos >= 0:
                best_match = sub_content
                best_score = 1.0
                best_pos = start_pos + exact_match_pos
        
        # 2. If no exact match, use difflib with higher threshold
        if not best_match:
            # Use difflib to find the best match with improved algorithm
            matcher = difflib.SequenceMatcher(None, sub_content, search_text)
            match = matcher.find_longest_match(0, len(sub_content), 0, len(search_text))
            
            if match.size > 0:
                match_score = match.size / len(sub_content)
                if match_score > 0.5:  # Increased threshold from default
                    best_match = search_text[match.b:match.b + match.size]
                    best_score = match_score
                    best_pos = start_pos + match.b
        
        # 3. If still no good match, try word-level matching
        if not best_match or best_score < 0.7:
            # Try matching individual words
            best_word_matches = []
            for word in segmented_sub:
                if word in search_text:
                    word_pos = search_text.find(word)
                    best_word_matches.append((word, start_pos + word_pos))
            
            if best_word_matches:
                # Use the script text between the first and last matched word
                if len(best_word_matches) > 1:
                    first_match = min(best_word_matches, key=lambda x: x[1])
                    last_match = max(best_word_matches, key=lambda x: x[1])
                    first_pos = first_match[1]
                    last_pos = last_match[1] + len(last_match[0])
                    
                    if last_pos - first_pos < len(sub_content) * 2:  # Reasonable length check
                        best_match = script_text[first_pos:last_pos]
                        best_score = 0.8  # Consider this a good match
                        best_pos = first_pos
        
        # If we found a good match, use it
        if best_match and best_score >= 0.5:
            # Create a new subtitle with the matched script text but keep the timing
            new_sub = srt.Subtitle(
                index=sub.index,
                start=sub.start,
                end=sub.end,
                content=best_match
            )
            aligned_subtitles.append(new_sub)
            
            # Update the position for the next search
            script_pos = best_pos + len(best_match)
        else:
            # If no good match found, keep the original subtitle
            # But try to clean it up a bit
            cleaned_content = sub_content
            # Remove common hallucination patterns
            cleaned_content = re.sub(r'minecraft', '', cleaned_content)
            cleaned_content = re.sub(r'and\s*$', '', cleaned_content)
            
            new_sub = srt.Subtitle(
                index=sub.index,
                start=sub.start,
                end=sub.end,
                content=cleaned_content
            )
            aligned_subtitles.append(new_sub)
    
    return aligned_subtitles

def align_standard_text(script_text: str, subtitles: List[srt.Subtitle]) -> List[srt.Subtitle]:
    """
    Align standard (non-Thai) script text with subtitles using word-level alignment.
    
    Args:
        script_text: The script text
        subtitles: List of subtitle objects
        
    Returns:
        List of aligned subtitle objects
    """
    # Create a list to store the aligned subtitles
    aligned_subtitles = []
    
    # Split the script into words
    script_words = script_text.split()
    
    # Current position in the script words
    script_pos = 0
    
    # Process each subtitle
    for sub in subtitles:
        # Skip empty subtitles
        if not sub.content.strip():
            aligned_subtitles.append(sub)
            continue
        
        # Split the subtitle content into words
        sub_words = sub.content.split()
        
        # Find the best match for this subtitle in the script
        best_match = ""
        best_score = 0
        best_pos = script_pos
        
        # Try different positions in the script
        for pos in range(max(0, script_pos - 10), min(len(script_words), script_pos + len(sub_words) + 10)):
            # Don't go past the end of the script
            if pos + len(sub_words) > len(script_words):
                break
                
            # Get the potential match
            potential_match = ' '.join(script_words[pos:pos + len(sub_words)])
            
            # Calculate the similarity score
            matcher = difflib.SequenceMatcher(None, sub.content.lower(), potential_match.lower())
            score = matcher.ratio()
            
            # Update the best match if this is better
            if score > best_score:
                best_match = potential_match
                best_score = score
                best_pos = pos
        
        # If we found a good match, use it
        if best_score > 0.6:
            new_sub = srt.Subtitle(
                index=sub.index,
                start=sub.start,
                end=sub.end,
                content=best_match
            )
            aligned_subtitles.append(new_sub)
            script_pos = best_pos + len(sub_words)
        else:
            # If no good match, keep the original subtitle
            aligned_subtitles.append(sub)
            # Don't advance script_pos in this case
    
    return aligned_subtitles

def process_subtitle_line_for_thai(line, max_width=None, max_words_per_line=None, position="bottom", x=None, y=None):
    """
    Process a subtitle line for Thai language, handling word segmentation and line breaks.
    
    Args:
        line: The subtitle line to process
        max_width: Maximum width of the subtitle line
        max_words_per_line: Maximum number of words per line
        position: Position of the subtitle (top, middle, bottom)
        x: Custom x position
        y: Custom y position
        
    Returns:
        Processed subtitle line
    """
    logger.info(f"Processing Thai subtitle line: {line}")
    logger.info(f"Parameters: max_width={max_width}, max_words_per_line={max_words_per_line}, position={position}, x={x}, y={y}")
    
    # If custom x and y are provided, add position override
    if x is not None and y is not None:
        logger.info(f"Using custom position: x={x}, y={y}")
        # Add ASS position tag
        line = f"{{\\pos({x},{y})}}{line}"
    else:
        # Apply standard positioning based on position parameter
        if position == "top":
            logger.info("Using top position")
            # For top position, use alignment 8 (top center)
            line = f"{{\\an8}}{line}"
        elif position == "middle":
            logger.info("Using middle position")
            # For middle position, use alignment 5 (middle center)
            line = f"{{\\an5}}{line}"
        else:  # bottom (default)
            logger.info("Using bottom position")
            # For bottom position, use alignment 2 (bottom center)
            line = f"{{\\an2}}{line}"
    
    # Add a semi-transparent background for better readability
    # Format: {\\bord3\\shad0\\3c&H000000&\\1a&H00&\\3a&H60&\\4a&H80&}
    # This creates a border, adds shadow, and sets alpha channels for visibility
    line = f"{{\\bord3\\shad1\\3c&H000000&\\1a&H00&\\3a&H60&\\4a&H80&}}{line}"
    
    logger.info(f"Processed Thai subtitle line: {line}")
    return line

def enhance_subtitles_from_segments(segments, script_text, language="en", settings=None):
    """
    Enhance subtitles from transcription segments and script text.
    
    Args:
        segments: List of transcription segments with start, end, and text
        script_text: Script text to align with segments
        language: Language code
        settings: Additional settings
        
    Returns:
        Tuple of (srt_path, ass_path)
    """
    try:
        logger.info(f"Enhancing subtitles from {len(segments)} segments")
        
        # Create a temporary directory for subtitle files
        temp_dir = tempfile.mkdtemp()
        logger.debug(f"Created temporary directory: {temp_dir}")
        
        # Extract settings
        if settings is None:
            settings = {}
            
        font_name = settings.get("font_name")
        font_size = settings.get("font_size", 24)
        position = settings.get("position", "bottom")
        margin_v = settings.get("margin_v", 30)
        max_width = settings.get("max_width", 90)
        line_color = settings.get("line_color", "white")
        outline_color = settings.get("outline_color", "black")
        word_color = settings.get("word_color", "#FFFF00")
        all_caps = settings.get("all_caps", False)
        max_words_per_line = settings.get("max_words_per_line", 7)
        alignment = settings.get("alignment", "center")
        bold = settings.get("bold", True)
        italic = settings.get("italic", False)
        underline = settings.get("underline", False)
        strikeout = settings.get("strikeout", False)
        outline = settings.get("outline", True)
        shadow = settings.get("shadow", True)
        border_style = settings.get("border_style", 1)
        outline_size = settings.get("outline_size", 2.0)
        back_color = settings.get("back_color", "&H80000000")
        
        # Check for custom x, y positioning
        custom_position = False
        pos_x = settings.get("x")
        pos_y = settings.get("y")
        
        if pos_x is not None and pos_y is not None:
            custom_position = True
            logger.debug(f"Using custom position coordinates: x={pos_x}, y={pos_y}")
        
        # Convert position to ASS alignment number
        # ASS alignment values:
        # 7 8 9 (top)
        # 4 5 6 (middle)
        # 1 2 3 (bottom)
        if isinstance(position, str):
            logger.debug(f"Converting position '{position}' to ASS alignment value")
            if position.lower() == "left":
                horizontal_align = 1  # Left
                logger.debug("Horizontal alignment: left (1)")
            elif position.lower() == "right":
                horizontal_align = 3  # Right
                logger.debug("Horizontal alignment: right (3)")
            else:  # center or any other value
                horizontal_align = 2  # Center
                logger.debug("Horizontal alignment: center (2)")
        else:
            horizontal_align = 2  # Default to center
            logger.debug("Using default horizontal alignment: center (2)")
            
        # Determine vertical alignment based on position
        if position.lower() == "top":
            vertical_align = 8  # Top-center
            logger.debug("Vertical position: top")
            if horizontal_align == 1:
                alignment = 7  # Top-left
                logger.debug("Final alignment: top-left (7)")
            elif horizontal_align == 3:
                alignment = 9  # Top-right
                logger.debug("Final alignment: top-right (9)")
            else:
                alignment = 8  # Top-center
                logger.debug("Final alignment: top-center (8)")
        elif position.lower() == "middle":
            logger.debug("Vertical position: middle")
            if horizontal_align == 1:
                alignment = 4  # Middle-left
                logger.debug("Final alignment: middle-left (4)")
            elif horizontal_align == 3:
                alignment = 6  # Middle-right
                logger.debug("Final alignment: middle-right (6)")
            else:
                alignment = 5  # Middle-center
                logger.debug("Final alignment: middle-center (5)")
            # For middle position, set margin_v to 0 to ensure it's truly centered
            margin_v = 0
            logger.debug(f"Setting margin_v to 0 for middle position")
        else:  # bottom or any other value
            logger.debug("Vertical position: bottom")
            if horizontal_align == 1:
                alignment = 1  # Bottom-left
                logger.debug("Final alignment: bottom-left (1)")
            elif horizontal_align == 3:
                alignment = 3  # Bottom-right
                logger.debug("Final alignment: bottom-right (3)")
            else:
                alignment = 2  # Bottom-center
                logger.debug("Final alignment: bottom-center (2)")
        
        # Generate SRT from segments
        srt_path = os.path.join(temp_dir, "subtitles.srt")
        logger.info(f"Generating SRT file at: {srt_path}")
        
        with open(srt_path, "w", encoding="utf-8") as f:
            logger.debug(f"Writing {len(segments)} segments to SRT file")
            for i, segment in enumerate(segments, 1):
                start_time = segment.get("start", 0)
                end_time = segment.get("end", 0)
                text = segment.get("text", "").strip()
                
                # Format times as SRT format (HH:MM:SS,mmm)
                start_formatted = format_time_srt(start_time)
                end_formatted = format_time_srt(end_time)
                
                logger.debug(f"Segment {i}: {start_formatted} --> {end_formatted}, Text length: {len(text)}")
                f.write(f"{i}\n")
                f.write(f"{start_formatted} --> {end_formatted}\n")
                f.write(f"{text}\n\n")
        
        logger.info(f"Generated SRT file with {len(segments)} segments")
        
        # Convert SRT to ASS with enhanced formatting
        ass_path = os.path.join(temp_dir, "subtitles.ass")
        logger.info(f"Converting SRT to ASS at: {ass_path}")
        logger.debug(f"ASS conversion parameters: font_name={font_name}, font_size={font_size}, alignment={alignment}, margin_v={margin_v}")
        
        # Create font formatting string
        font_formatting = {
            "bold": bold,
            "italic": italic,
            "underline": underline,
            "strikeout": strikeout,
            "outline": outline,
            "shadow": shadow,
            "border_style": border_style,
            "outline_size": outline_size,
            "back_color": back_color
        }
        
        # Convert alignment string to ASS alignment number
        if isinstance(alignment, str):
            if alignment.lower() == "left":
                alignment = 1
            elif alignment.lower() == "right":
                alignment = 3
            else:  # center or any other value
                alignment = 2
        
        # Convert SRT content to ASS format
        ass_content = """[Script Info]
Title: Auto-generated Thai subtitles
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1920
PlayResY: 1080

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,{font_name},{font_size},&HFFFFFF,&HFFFFFF,&H000000,{back_color},{1 if bold else 0},{1 if italic else 0},{1 if underline else 0},{1 if strikeout else 0},100,100,0,0,{border_style},{outline_size if outline else 0},{2 if shadow else 0},{alignment},20,20,{margin_v},1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""
        
        # Parse SRT content
        import re
        logger.debug("Reading SRT file for conversion to ASS")
        srt_content = open(srt_path, 'r', encoding='utf-8').read()
        logger.debug(f"SRT content length: {len(srt_content)} characters")
        
        pattern = r'(\d+)\n(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})\n([\s\S]*?)(?=\n\n|\Z)'
        matches = re.findall(pattern, srt_content, re.MULTILINE)
        logger.debug(f"Found {len(matches)} subtitle entries in SRT file")
        
        # Convert SRT time format to ASS time format
        def convert_time_to_ass(time_str):
            # Convert from 00:00:00,000 to 0:00:00.00
            h, m, s = time_str.split(':')
            s, ms = s.split(',')
            return f"{int(h)}:{m}:{s}.{ms[:2]}"
        
        # Add dialogue lines
        logger.debug("Processing subtitle entries for ASS format")
        for match in matches:
            _, start_time, end_time, text = match
            start_time_ass = convert_time_to_ass(start_time)
            end_time_ass = convert_time_to_ass(end_time)
            logger.debug(f"Converting time: {start_time} -> {start_time_ass}, {end_time} -> {end_time_ass}")
            
            # Process Thai text with proper line breaks
            if language.lower() == "th":
                logger.debug(f"Processing Thai text: '{text}' (length: {len(text)})")
                text = process_subtitle_line_for_thai(text, max_width=max_width, max_words_per_line=max_words_per_line, position=position, x=pos_x, y=pos_y)
                logger.debug(f"Processed Thai text: '{text}'")
            
            # Add the dialogue line
            if custom_position:
                # Use custom x,y coordinates for positioning
                text = "{\\an5\\pos(" + str(pos_x) + "," + str(pos_y) + ")}" + text
                dialogue_line = f"Dialogue: 0,{start_time_ass},{end_time_ass},Default,,0,0,0,,{text}\n"
                logger.debug(f"Generated dialogue line with custom positioning at x={pos_x}, y={pos_y}")
            elif position.lower() == "top":
                # For top position, use \an8 tag (top-center) and explicit positioning
                # Calculate top position with margin (50px from top for 1080p video)
                top_margin = margin_v if margin_v is not None else 50
                text = "{\\an8\\pos(960," + str(top_margin) + ")}" + text
                dialogue_line = f"Dialogue: 0,{start_time_ass},{end_time_ass},Default,,0,0,0,,{text}\n"
                logger.debug(f"Generated dialogue line for top position with explicit positioning")
            elif position.lower() == "middle":
                # For middle position, set MarginV to 0 in the dialogue line to ensure it's centered
                # Use the \pos tag to force vertical positioning in the middle
                # Calculate middle position (PlayResY/2 = 540 for 1080p video)
                text = "{\\an5\\pos(960,540)}" + text
                dialogue_line = f"Dialogue: 0,{start_time_ass},{end_time_ass},Default,,0,0,0,,{text}\n"
                logger.debug(f"Generated dialogue line for middle position with explicit positioning")
            else:
                # For bottom position, use \an2 tag (bottom-center) and explicit positioning
                # Calculate bottom position with margin (1080 - margin_v for 1080p video)
                bottom_margin = 1080 - (margin_v if margin_v is not None else 50)
                text = "{\\an2\\pos(960," + str(bottom_margin) + ")}" + text
                dialogue_line = f"Dialogue: 0,{start_time_ass},{end_time_ass},Default,,0,0,0,,{text}\n"
                logger.debug(f"Generated dialogue line for bottom position with explicit positioning")
            ass_content += dialogue_line
        
        # Write the ASS file
        with open(ass_path, 'w', encoding='utf-8') as f_ass:
            f_ass.write(ass_content)
        
        logger.info(f"Generated ASS file with enhanced formatting")
        
        return srt_path, ass_path
        
    except Exception as e:
        logger.error(f"Error in subtitle enhancement: {str(e)}")
        raise

def format_time_srt(time_in_seconds):
    hours = int(time_in_seconds // 3600)
    minutes = int((time_in_seconds % 3600) // 60)
    seconds = int(time_in_seconds % 60)
    milliseconds = int((time_in_seconds - int(time_in_seconds)) * 1000)
    
    return f"{hours:02d}:{minutes:02d}:{seconds:02d},{milliseconds:03d}"

def convert_srt_time_to_ass(time_str):
    parts = time_str.split(":")
    hours = int(parts[0])
    minutes = int(parts[1])
    seconds_and_milliseconds = parts[2].split(",")
    seconds = int(seconds_and_milliseconds[0])
    milliseconds = int(seconds_and_milliseconds[1])
    
    total_seconds = hours * 3600 + minutes * 60 + seconds + milliseconds / 1000
    
    return f"{total_seconds:.3f}"